# -*- coding: utf-8 -*-
"""MobileNetV2_Digit_Fashion_MNIST

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C_2iK3XTXtwM8ht4K1ITXsxjhX2VCg2C
"""

import matplotlib.pyplot as plt
import tensorflow as tf

# MNIST / Fashion MNIST Dataset
mnist = tf.keras.datasets.mnist
fashion_mnist = tf.keras.datasets.fashion_mnist

(n_image_train, n_label_train), (n_image_test, n_label_test) = mnist.load_data()
n_image_train, n_image_test = n_image_train / 255.0, n_image_test / 255.0

(f_image_train, f_label_train), (f_image_test, f_label_test) = fashion_mnist.load_data()
f_image_train, f_image_test = f_image_train / 255.0, f_image_test / 255.0

"""Dataset processing"""

import cv2
import numpy as np
from keras.utils import to_categorical

# define common functions

def resize(img):
    # Resize the image first
    img = cv2.resize(img, (input_size, input_size))

    # convert to 3 channel (RGB)
    img = np.stack((img, )*3, axis=-1)

    # Make sure it is a float32
    return img.astype(np.float32)

def data_generator(data, label, batch_size=64):
    num_samples = data.shape[0]


    while True:
        for i in range(0, num_samples, batch_size):
            # Change the input shape 'N'with batch size (N * H * W * C)
            x_data = [resize(img) for img in data[i:i+batch_size]]
            y_data = label[i:i + batch_size]

            # convert to numpy array since this what keras required
            yield np.array(x_data), np.array(y_data)


#Convert labels to one hot encoding
n_label_train_encoded = to_categorical(n_label_train, num_classes=10, dtype='float32')
n_label_test_encoded = to_categorical(n_label_test, num_classes=10, dtype='float32')

# prepare data feeder for keras model
n_train_generator = data_generator(n_image_train, n_label_train_encoded, batch_size=64)

# show the results
print("Encoded Label shape:", n_label_train_encoded.shape)
print(" * Label[0]:", n_label_train[0])
print(" * Label[0] (encoded):", n_label_train_encoded[0])

#Convert labels to one hot encoding
f_label_train_encoded = to_categorical(f_label_train, num_classes=10, dtype='float32')
f_label_test_encoded = to_categorical(f_label_test, num_classes=10, dtype='float32')

# prepare data feeder for keras model
f_train_generator = data_generator(f_image_train, f_label_train_encoded, batch_size=64)

# show the results
print("Encoded Label shape:", f_label_train_encoded.shape)
print(" * Label[0]:", f_label_train[0])
print(" * Label[0] (encoded):", f_label_train_encoded[0])

"""Handwritten Digit"""

from keras.applications import MobileNetV2
from keras.layers import Dense, Input, Dropout
from keras.models import Model

number_model_name = "number_mnist_mobilenetv2"
fashion_model_name = "fashion_mnist_mobilenetv2"

# Assume we use 96x96
input_size = 96
input_shape = (input_size, input_size, 3)

# Input
input_tensor = Input(shape=input_shape)

# Base MobileNetV2 model  ##
base_model = MobileNetV2(
    include_top=False, # transfer learning
    input_tensor=input_tensor,
    input_shape=input_shape,
    pooling='avg')

for layer in base_model.layers:
    layer.trainable = False  # If a model is a freeze, the layer is not trainable

### Handwritten Digit MNIST Model ###
layer = Dense(256, activation='relu')(base_model.output)
layer = Dropout(.25)(layer)
output_tensor = Dense(10, activation='softmax')(layer)

# Build and Train Digit MNIST Model
n_model = Model(inputs=input_tensor, outputs=output_tensor, name=number_model_name)
n_model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['categorical_accuracy'])

n_model.fit(
    n_train_generator,
    steps_per_epoch=2000,
    epochs=10)

n_model.save(f"{number_model_name}.h5")

### Fashion MNIST Model ###
layer = Dense(256, activation='relu')(base_model.output)
layer = Dropout(.25)(layer)
output_tensor = Dense(10, activation='softmax')(layer)

# Build and Train Fashion MNIST model
f_model = Model(inputs=input_tensor, outputs=output_tensor, name=fashion_model_name)
f_model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['categorical_accuracy'])

f_model.fit(
    f_train_generator,
    steps_per_epoch=2000,
    epochs=20)

f_model.save(f"{fashion_model_name}.h5")

import tensorflow as tf
from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2
from keras.models import load_model

model = load_model("./fashion_mnist_mobilenetv2.h5")
# Convert Keras model to ConcreteFunction
full_model = tf.function(lambda x: model(x)).get_concrete_function(
    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))

# Get frozen ConcreteFunction
frozen_func = convert_variables_to_constants_v2(full_model)
frozen_func.graph.as_graph_def()

# Save frozen graph to disk
saved_file = tf.io.write_graph(graph_or_graph_def=frozen_func.graph,
                  logdir='',
                  name="fashion_mnist_mobilenetv2.pb",
                  as_text=False)

import os, sys
from google.colab import drive

model_name = "number_mnist_mobilenetv2"
# mount Google drive
drive.mount('/content/mnt')

!cp -f "{model_name}.h5" "/content/mnt/MyDrive/training_openvino/"

model_name = "number_mnist_mobilenetv2"
!cp -f "{model_name}.pb" "/content/mnt/MyDrive/training_openvino/"

"""Run keras inferencing"""

import time
# keras
from keras.models import load_model
new_model = load_model("number_mnist_mobilenetv2.h5")

# prepare image
image = np.array([resize(n_image_test[0])])
predictions = new_model(image)  # warming up

# measure time
start = time.time()
predictions = new_model(image)
print("Keras inference time:", time.time() - start)

# print output
print(" * Result:", np.argmax(predictions))

# Accuracy check
CNT=1000
err=0
error_list = np.array([],dtype=np.uint8)
error_pred = np.array([],dtype=np.uint8)

# keras
new_model = load_model("./number_mnist_mobilenetv2.h5")

print("########### NUMBER ERR ############")
err = 0
for idx in range(CNT):
  image = np.array([resize(n_image_test[idx])])
  predictions = new_model(image)
  if np.argmax(predictions) != n_label_test[idx]:
    err += 1

print("The Error of Keras is", err * 100 / CNT, "%")
print("#######################################")

# Accuracy check
CNT=1000
err=0
error_list = np.array([],dtype=np.uint8)
error_pred = np.array([],dtype=np.uint8)

# keras
new_model = load_model("./fashion_mnist_mobilenetv2.h5")

print("############# Fasion ERR #############")
err = 0
for idx in range(CNT):
  image = np.array([resize(f_image_test[idx])])
  predictions = new_model(image)
  if np.argmax(predictions) != f_label_test[idx]:
    err += 1

print("The Error of Keras is", err * 100 / CNT, "%")
print("#######################################")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import time
# 
# import cv2
# import numpy as np
# from keras.datasets import mnist
# from openvino.inference_engine import IECore
# 
# _, (data_test, label_test) = mnist.load_data()
# 
# # input data size when training
# input_size = 96
# 
# def resize(img):
#     # Resize the image first
#     img = cv2.resize(img, (input_size, input_size))
# 
#     # convert to 3 channel (RGB)
#     img = np.stack((img, )*3, axis=-1)
# 
#     # Make sure it is a float32
#     return img.astype(np.float32)
# 
# def nchw(img):
#     # Add Batch size(N) axis
#     img = img[np.newaxis, :, :, :]  # HWC to NHWC
#     return img.transpose((0, 3, 1, 2))  # NHWC to NCHW
# 
# # initialize Inference Engine (IE)
# ie = IECore()
# 
# # read model and prepare network
# net = ie.read_network(model="./ir/custom_mnist_mobilenetv2.xml",
#                       weights="./ir/custom_mnist_mobilenetv2.bin")
# 
# # create executable network
# exec_net = ie.load_network(network=net,
#                            device_name="CPU",
#                            num_requests=1)
# 
# # Read and pre-process input images
# image = nchw(resize(data_test[0]))
# 
# input_name = next(iter(net.input_info))
# res = exec_net.infer({input_name: image}) # warming up
# 
# # measure time
# start = time.time()
# res = exec_net.infer({input_name: image})
# print("OpenVINO inference time:", time.time() - start)
# 
# # print output
# out_blob = next(iter(net.outputs))
# res = res[out_blob]
# print(" * Result:", np.argmax(res))
# 
# print("############### openVINO ##############")
# for idx in range(CNT):
#     input = nchw(resize(data_test[idx]))
#     infer_result = exec_net.infer({input_name: input})
#     predicted_value = np.argmax(infer_result[out_blob])
#     #print(predicted_value,label_test[idx])
# 
#     if (predicted_value != label_test[idx]):
#         err += 1
#         error_list = np.append(error_list, idx)
#         error_pred = np.append(error_pred, predicted_value)
# 
# print("The Error of Openvino is",err, "items")
# print("#######################################")
# 
#

!source /opt/intel/openvino_2021/bin/setupvars.sh && python3 app.py

